// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./Interfaces.sol";

/**
 * @title ArbitrageBot (Universal Execution Engine)
 * @author Gemini
 * @notice This contract is a highly flexible execution engine for complex arbitrage trades.
 * It is designed to be controlled by a sophisticated off-chain bot that constructs the transaction data.
 * This architecture provides maximum flexibility, allowing interaction with any protocol without contract changes.
 * MEV resistance is handled by restricting execution to an authorized RELAYER_ROLE (your off-chain bot).
 */
contract ArbitrageBot is AccessControl, Pausable, ReentrancyGuard {

    //================================================================================
    // Roles
    //================================================================================
    bytes32 public constant OWNER_ROLE = keccak256("OWNER_ROLE");
    bytes32 public constant EMERGENCY_ROLE = keccak256("EMERGENCY_ROLE");
    bytes32 public constant RELAYER_ROLE = keccak256("RELAYER_ROLE"); // For MEV protection

    //================================================================================
    // State Variables
    //================================================================================
    address public treasury; // Address where profits are sent
    address public aaveLendingPool; // Aave V2 Lending Pool address for flash loans
    mapping(address => bool) public blacklistedTokens;

    //================================================================================
    // Structs
    //================================================================================

    /**
     * @dev Represents a single action in the arbitrage path, such as a swap.
     * The `payload` is the raw calldata for the function call on the `target` address.
     * This must be generated by the off-chain bot.
     */
    struct Action {
        address target; // The address of the contract to call (e.g., DEX router, aggregator)
        bytes payload;  // The calldata for the call
        address tokenToApprove; // The token that needs approval for this action
        uint256 amountToApprove; // The amount to approve
    }

    //================================================================================
    // Custom Errors
    //================================================================================
    error DeadlineExpired(uint256 deadline, uint256 currentTime);
    error InsufficientProfit(uint256 required, uint256 actual);
    error UnauthorizedCaller(address caller);
    error InvalidAmount();
    error TokenBlacklisted(address token);
    error InvalidPath();
    error ActionFailed(uint256 step);

    //================================================================================
    // Events
    //================================================================================
    event ArbitrageExecuted(
        bytes32 indexed tradeId,
        address indexed executor,
        uint256 amountIn,
        uint256 profit
    );
    event TreasuryUpdated(address indexed newTreasury);
    event TokenBlacklistedEvent(address indexed token);
    event RelayerRoleGranted(address indexed newRelayer);
    event RelayerRoleRevoked(address indexed oldRelayer);

    //================================================================================
    // Constructor
    //================================================================================
    constructor(
        address _initialOwner,
        address _treasury,
        address _aaveLendingPool
    ) {
        _grantRole(DEFAULT_ADMIN_ROLE, _initialOwner);
        _grantRole(OWNER_ROLE, _initialOwner);
        _grantRole(EMERGENCY_ROLE, _initialOwner);
        _grantRole(RELAYER_ROLE, _initialOwner); // Owner can act as relayer initially

        treasury = _treasury;
        aaveLendingPool = _aaveLendingPool;
    }

    //================================================================================
    // Core Arbitrage Logic
    //================================================================================

    /**
     * @notice Executes a generic, multi-step arbitrage trade.
     * @dev All estimation and calldata generation must be done off-chain.
     * @param actions An array of Action structs defining the trade route.
     * @param initialToken The token being used for the arbitrage.
     * @param amountIn The initial amount of the first token to trade.
     * @param minFinalAmount The minimum amount of `initialToken` expected back after all swaps to consider the trade successful.
     * @param deadline The deadline for the transaction.
     */
    function executeArbitrage(
        Action[] calldata actions,
        address initialToken,
        uint256 amountIn,
        uint256 minFinalAmount,
        uint256 deadline
    )
        external
        whenNotPaused
        nonReentrant
        onlyRole(RELAYER_ROLE)
    {
        if (block.timestamp > deadline) revert DeadlineExpired(deadline, block.timestamp);
        if (amountIn == 0) revert InvalidAmount();
        if (actions.length == 0) revert InvalidPath();
        if (blacklistedTokens[initialToken]) revert TokenBlacklisted(initialToken);

        // --- Execute Actions ---
        for (uint i = 0; i < actions.length; i++) {
            Action calldata action = actions[i];
            
            // Approve the target contract to spend the required token
            if (action.tokenToApprove != address(0) && action.amountToApprove > 0) {
                 IERC20(action.tokenToApprove).approve(action.target, action.amountToApprove);
            }

            // Execute the generic call
            (bool success, ) = action.target.call(action.payload);
            if (!success) {
                revert ActionFailed(i);
            }
        }

        // --- Post-Swap Profit Validation (Final Check) ---
        uint256 finalAmount = IERC20(initialToken).balanceOf(address(this));
        if (finalAmount < minFinalAmount) {
            revert InsufficientProfit(minFinalAmount, finalAmount);
        }

        // --- Send Profit ---
        uint256 finalProfit = finalAmount - amountIn;
        if (finalProfit > 0) {
            IERC20(initialToken).transfer(treasury, finalProfit);
        }

        emit ArbitrageExecuted(keccak256(abi.encode(actions, amountIn, deadline)), msg.sender, amountIn, finalProfit);
    }

    //================================================================================
    // Admin & Emergency Functions
    //================================================================================

    function pause() public onlyRole(EMERGENCY_ROLE) { _pause(); }
    function unpause() public onlyRole(EMERGENCY_ROLE) { _unpause(); }

    function emergencyWithdraw(address tokenAddress) external onlyRole(OWNER_ROLE) {
        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));
        if (balance > 0) {
            IERC20(tokenAddress).transfer(treasury, balance);
        }
    }

    function updateTreasury(address _newTreasury) external onlyRole(OWNER_ROLE) {
        treasury = _newTreasury;
        emit TreasuryUpdated(_newTreasury);
    }

    function blacklistToken(address _token) external onlyRole(EMERGENCY_ROLE) {
        blacklistedTokens[_token] = true;
        emit TokenBlacklistedEvent(_token);
    }

    /**
     * @notice Grants the RELAYER_ROLE to a new address.
     * @dev Can only be called by the contract owner.
     * @param _relayer The address of the bot wallet to be granted the role.
     */
    function grantRelayerRole(address _relayer) external onlyRole(OWNER_ROLE) {
        _grantRole(RELAYER_ROLE, _relayer);
        emit RelayerRoleGranted(_relayer);
    }

    /**
     * @notice Revokes the RELAYER_ROLE from an address.
     * @dev Can only be called by the contract owner.
     * @param _relayer The address of the bot wallet to have its role revoked.
     */
    function revokeRelayerRole(address _relayer) external onlyRole(OWNER_ROLE) {
        _revokeRole(RELAYER_ROLE, _relayer);
        emit RelayerRoleRevoked(_relayer);
    }
}